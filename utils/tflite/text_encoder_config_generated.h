/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TEXTENCODERCONFIG_LIBTEXTCLASSIFIER3_H_
#define FLATBUFFERS_GENERATED_TEXTENCODERCONFIG_LIBTEXTCLASSIFIER3_H_

#include "flatbuffers/flatbuffers.h"

namespace libtextclassifier3 {

struct TextEncoderConfig;
struct TextEncoderConfigT;

struct TextEncoderConfigT : public flatbuffers::NativeTable {
  typedef TextEncoderConfig TableType;
  int32_t start_code;
  int32_t end_code;
  int32_t encoding_offset;
  std::string normalization_charsmap;
  std::string normalization_charsmap_values;
  bool add_dummy_prefix;
  bool remove_extra_whitespaces;
  bool escape_whitespaces;
  std::vector<float> pieces_scores;
  std::string pieces;
  TextEncoderConfigT()
      : start_code(0),
        end_code(1),
        encoding_offset(2),
        add_dummy_prefix(true),
        remove_extra_whitespaces(true),
        escape_whitespaces(true) {
  }
};

struct TextEncoderConfig FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TextEncoderConfigT NativeTableType;
  enum {
    VT_START_CODE = 4,
    VT_END_CODE = 6,
    VT_ENCODING_OFFSET = 8,
    VT_NORMALIZATION_CHARSMAP = 10,
    VT_NORMALIZATION_CHARSMAP_VALUES = 12,
    VT_ADD_DUMMY_PREFIX = 14,
    VT_REMOVE_EXTRA_WHITESPACES = 16,
    VT_ESCAPE_WHITESPACES = 18,
    VT_PIECES_SCORES = 20,
    VT_PIECES = 22
  };
  int32_t start_code() const {
    return GetField<int32_t>(VT_START_CODE, 0);
  }
  int32_t end_code() const {
    return GetField<int32_t>(VT_END_CODE, 1);
  }
  int32_t encoding_offset() const {
    return GetField<int32_t>(VT_ENCODING_OFFSET, 2);
  }
  const flatbuffers::String *normalization_charsmap() const {
    return GetPointer<const flatbuffers::String *>(VT_NORMALIZATION_CHARSMAP);
  }
  const flatbuffers::String *normalization_charsmap_values() const {
    return GetPointer<const flatbuffers::String *>(VT_NORMALIZATION_CHARSMAP_VALUES);
  }
  bool add_dummy_prefix() const {
    return GetField<uint8_t>(VT_ADD_DUMMY_PREFIX, 1) != 0;
  }
  bool remove_extra_whitespaces() const {
    return GetField<uint8_t>(VT_REMOVE_EXTRA_WHITESPACES, 1) != 0;
  }
  bool escape_whitespaces() const {
    return GetField<uint8_t>(VT_ESCAPE_WHITESPACES, 1) != 0;
  }
  const flatbuffers::Vector<float> *pieces_scores() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_PIECES_SCORES);
  }
  const flatbuffers::String *pieces() const {
    return GetPointer<const flatbuffers::String *>(VT_PIECES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_START_CODE) &&
           VerifyField<int32_t>(verifier, VT_END_CODE) &&
           VerifyField<int32_t>(verifier, VT_ENCODING_OFFSET) &&
           VerifyOffset(verifier, VT_NORMALIZATION_CHARSMAP) &&
           verifier.Verify(normalization_charsmap()) &&
           VerifyOffset(verifier, VT_NORMALIZATION_CHARSMAP_VALUES) &&
           verifier.Verify(normalization_charsmap_values()) &&
           VerifyField<uint8_t>(verifier, VT_ADD_DUMMY_PREFIX) &&
           VerifyField<uint8_t>(verifier, VT_REMOVE_EXTRA_WHITESPACES) &&
           VerifyField<uint8_t>(verifier, VT_ESCAPE_WHITESPACES) &&
           VerifyOffset(verifier, VT_PIECES_SCORES) &&
           verifier.Verify(pieces_scores()) &&
           VerifyOffset(verifier, VT_PIECES) &&
           verifier.Verify(pieces()) &&
           verifier.EndTable();
  }
  TextEncoderConfigT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TextEncoderConfigT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TextEncoderConfig> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TextEncoderConfigT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TextEncoderConfigBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_start_code(int32_t start_code) {
    fbb_.AddElement<int32_t>(TextEncoderConfig::VT_START_CODE, start_code, 0);
  }
  void add_end_code(int32_t end_code) {
    fbb_.AddElement<int32_t>(TextEncoderConfig::VT_END_CODE, end_code, 1);
  }
  void add_encoding_offset(int32_t encoding_offset) {
    fbb_.AddElement<int32_t>(TextEncoderConfig::VT_ENCODING_OFFSET, encoding_offset, 2);
  }
  void add_normalization_charsmap(flatbuffers::Offset<flatbuffers::String> normalization_charsmap) {
    fbb_.AddOffset(TextEncoderConfig::VT_NORMALIZATION_CHARSMAP, normalization_charsmap);
  }
  void add_normalization_charsmap_values(flatbuffers::Offset<flatbuffers::String> normalization_charsmap_values) {
    fbb_.AddOffset(TextEncoderConfig::VT_NORMALIZATION_CHARSMAP_VALUES, normalization_charsmap_values);
  }
  void add_add_dummy_prefix(bool add_dummy_prefix) {
    fbb_.AddElement<uint8_t>(TextEncoderConfig::VT_ADD_DUMMY_PREFIX, static_cast<uint8_t>(add_dummy_prefix), 1);
  }
  void add_remove_extra_whitespaces(bool remove_extra_whitespaces) {
    fbb_.AddElement<uint8_t>(TextEncoderConfig::VT_REMOVE_EXTRA_WHITESPACES, static_cast<uint8_t>(remove_extra_whitespaces), 1);
  }
  void add_escape_whitespaces(bool escape_whitespaces) {
    fbb_.AddElement<uint8_t>(TextEncoderConfig::VT_ESCAPE_WHITESPACES, static_cast<uint8_t>(escape_whitespaces), 1);
  }
  void add_pieces_scores(flatbuffers::Offset<flatbuffers::Vector<float>> pieces_scores) {
    fbb_.AddOffset(TextEncoderConfig::VT_PIECES_SCORES, pieces_scores);
  }
  void add_pieces(flatbuffers::Offset<flatbuffers::String> pieces) {
    fbb_.AddOffset(TextEncoderConfig::VT_PIECES, pieces);
  }
  explicit TextEncoderConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TextEncoderConfigBuilder &operator=(const TextEncoderConfigBuilder &);
  flatbuffers::Offset<TextEncoderConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TextEncoderConfig>(end);
    return o;
  }
};

inline flatbuffers::Offset<TextEncoderConfig> CreateTextEncoderConfig(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t start_code = 0,
    int32_t end_code = 1,
    int32_t encoding_offset = 2,
    flatbuffers::Offset<flatbuffers::String> normalization_charsmap = 0,
    flatbuffers::Offset<flatbuffers::String> normalization_charsmap_values = 0,
    bool add_dummy_prefix = true,
    bool remove_extra_whitespaces = true,
    bool escape_whitespaces = true,
    flatbuffers::Offset<flatbuffers::Vector<float>> pieces_scores = 0,
    flatbuffers::Offset<flatbuffers::String> pieces = 0) {
  TextEncoderConfigBuilder builder_(_fbb);
  builder_.add_pieces(pieces);
  builder_.add_pieces_scores(pieces_scores);
  builder_.add_normalization_charsmap_values(normalization_charsmap_values);
  builder_.add_normalization_charsmap(normalization_charsmap);
  builder_.add_encoding_offset(encoding_offset);
  builder_.add_end_code(end_code);
  builder_.add_start_code(start_code);
  builder_.add_escape_whitespaces(escape_whitespaces);
  builder_.add_remove_extra_whitespaces(remove_extra_whitespaces);
  builder_.add_add_dummy_prefix(add_dummy_prefix);
  return builder_.Finish();
}

inline flatbuffers::Offset<TextEncoderConfig> CreateTextEncoderConfigDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t start_code = 0,
    int32_t end_code = 1,
    int32_t encoding_offset = 2,
    const char *normalization_charsmap = nullptr,
    const char *normalization_charsmap_values = nullptr,
    bool add_dummy_prefix = true,
    bool remove_extra_whitespaces = true,
    bool escape_whitespaces = true,
    const std::vector<float> *pieces_scores = nullptr,
    const char *pieces = nullptr) {
  return libtextclassifier3::CreateTextEncoderConfig(
      _fbb,
      start_code,
      end_code,
      encoding_offset,
      normalization_charsmap ? _fbb.CreateString(normalization_charsmap) : 0,
      normalization_charsmap_values ? _fbb.CreateString(normalization_charsmap_values) : 0,
      add_dummy_prefix,
      remove_extra_whitespaces,
      escape_whitespaces,
      pieces_scores ? _fbb.CreateVector<float>(*pieces_scores) : 0,
      pieces ? _fbb.CreateString(pieces) : 0);
}

flatbuffers::Offset<TextEncoderConfig> CreateTextEncoderConfig(flatbuffers::FlatBufferBuilder &_fbb, const TextEncoderConfigT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline TextEncoderConfigT *TextEncoderConfig::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TextEncoderConfigT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TextEncoderConfig::UnPackTo(TextEncoderConfigT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = start_code(); _o->start_code = _e; };
  { auto _e = end_code(); _o->end_code = _e; };
  { auto _e = encoding_offset(); _o->encoding_offset = _e; };
  { auto _e = normalization_charsmap(); if (_e) _o->normalization_charsmap = _e->str(); };
  { auto _e = normalization_charsmap_values(); if (_e) _o->normalization_charsmap_values = _e->str(); };
  { auto _e = add_dummy_prefix(); _o->add_dummy_prefix = _e; };
  { auto _e = remove_extra_whitespaces(); _o->remove_extra_whitespaces = _e; };
  { auto _e = escape_whitespaces(); _o->escape_whitespaces = _e; };
  { auto _e = pieces_scores(); if (_e) { _o->pieces_scores.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pieces_scores[_i] = _e->Get(_i); } } };
  { auto _e = pieces(); if (_e) _o->pieces = _e->str(); };
}

inline flatbuffers::Offset<TextEncoderConfig> TextEncoderConfig::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TextEncoderConfigT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTextEncoderConfig(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TextEncoderConfig> CreateTextEncoderConfig(flatbuffers::FlatBufferBuilder &_fbb, const TextEncoderConfigT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TextEncoderConfigT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _start_code = _o->start_code;
  auto _end_code = _o->end_code;
  auto _encoding_offset = _o->encoding_offset;
  auto _normalization_charsmap = _o->normalization_charsmap.empty() ? 0 : _fbb.CreateString(_o->normalization_charsmap);
  auto _normalization_charsmap_values = _o->normalization_charsmap_values.empty() ? 0 : _fbb.CreateString(_o->normalization_charsmap_values);
  auto _add_dummy_prefix = _o->add_dummy_prefix;
  auto _remove_extra_whitespaces = _o->remove_extra_whitespaces;
  auto _escape_whitespaces = _o->escape_whitespaces;
  auto _pieces_scores = _o->pieces_scores.size() ? _fbb.CreateVector(_o->pieces_scores) : 0;
  auto _pieces = _o->pieces.empty() ? 0 : _fbb.CreateString(_o->pieces);
  return libtextclassifier3::CreateTextEncoderConfig(
      _fbb,
      _start_code,
      _end_code,
      _encoding_offset,
      _normalization_charsmap,
      _normalization_charsmap_values,
      _add_dummy_prefix,
      _remove_extra_whitespaces,
      _escape_whitespaces,
      _pieces_scores,
      _pieces);
}

}  // namespace libtextclassifier3

#endif  // FLATBUFFERS_GENERATED_TEXTENCODERCONFIG_LIBTEXTCLASSIFIER3_H_
